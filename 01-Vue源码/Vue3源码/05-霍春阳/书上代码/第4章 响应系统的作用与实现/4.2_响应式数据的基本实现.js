/**
 * @Author liming
 * @Date 2022/12/27 11:38
 **/
// 存储副作用函数的桶
const bucket = new Set()
//bucket为集合类型

// 原始数据
const data = {text: 'hello world'}


/**对原始数据的代理
 * 代理是目标对象的抽象。从很多方面看，代理类似 C++指针，因为它可以
 * 用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。
 * 但直接操作会绕过代理施予的行为。
 *
 * 在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同
 * 就是代码中操作的是代理对象。
 */
const obj = new Proxy(data, {
    // 拦截读取操作
    /**
     * 只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正
     * 常的行为
     * 所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如， get()
     * 捕获器会接收到目标对象、要查询的属性和代理对象三个参数。
     */
    get(target, key) {
        console.log('get函数触发了')
        // 将副作用函数 effect 添加到存储副作用函数的桶
        bucket.add(effect)
        console.log(bucket,'bucket')
        // 返回属性值
        return target[key]
    },
    // 拦截设置操作
    set(target, key, newVal) {
        console.log('set函数触发了')
        // 先设置属性
        target[key] = newVal
        // 后把副作用函数从桶里取出并执行(此时的text是新值了)
        bucket.forEach(fn => fn())
        // 返回 true 代表设置操作成功
        return true
    }
})

console.log(obj,'生成的代理对象1')

//代码测试
function effect(){
    console.log('effect run') // 会打印 2 次
    document.body.innerText = obj.text
}

/**
 * 当副作用函数 effect 执行时，会触发字段 obj.text 的读取操作；
 * 当修改 obj.text 的值时，会触发字段 obj.text 的设置操作
 */
effect()

// 1 秒后修改响应式数据
setTimeout(()=>{
    // obj.text = 'hello vue3'
    //修改obj会触发get和set函数
    // console.log(obj,'生成的代理对象2')
    // 副作用函数中并没有读取 notExist 属性的值
    /**
     * 可以看到，匿名副作用函数内部读取了字段 obj.text 的值，于
     * 是匿名副作用函数与字段 obj.text 之间会建立响应联系。接着，我
     * 们开启了一个定时器，一秒钟后为对象 obj 添加新的 notExist 属
     * 性。我们知道，在匿名副作用函数内并没有读取 obj.notExist 属性
     * 的值，所以理论上，字段 obj.notExist 并没有与副作用建立响应联
     * 系，因此，定时器内语句的执行不应该触发匿名副作用函数重新执
     * 行。但如果我们执行上述这段代码就会发现，定时器到时后，匿名副
     * 作用函数却重新执行了，这是不正确的。为了解决这个问题，我们需
     * 要重新设计“桶”的数据结构。
     *
     * 在上一节的例子中，我们使用一个 Set 数据结构作为存储副作用
     * 函数的“桶”。导致该问题的根本原因是，我们没有在副作用函数与被
     * 操作的目标字段之间建立明确的联系。例如当读取属性时，无论读取
     * 的是哪一个属性，其实都一样，都会把副作用函数收集到“桶”里；当
     * 设置属性时，无论设置的是哪一个属性，也都会把“桶”里的副作用函
     * 数取出并执行。副作用函数与被操作的字段之间没有明确的联系。解
     * 决方法很简单，只需要在副作用函数与被操作的字段之间建立联系即
     * 可，这就需要我们重新设计“桶”的数据结构，而不能简单地使用一个
     * Set 类型的数据作为“桶”了。
     */
    obj.notExist = 'hello vue3'
},3000)

/**
 * 首先，我们创建了一个用于存储副作用函数的桶 bucket，它是
 * Set 类型。接着定义原始数据 data，obj 是原始数据的代理对象，我
 * 们分别设置了 get 和 set 拦截函数，用于拦截读取和设置操作。当读
 * 取属性时将副作用函数 effect 添加到桶里，即
 * bucket.add(effect)，然后返回属性值；当设置属性值时先更新原
 * 始数据，再将副作用函数从桶里取出并重新执行，这样我们就实现了
 * 响应式数据
 *
 * 但是目前的实现还存在很多缺陷，例如我们直接通过名字
 * （effect）来获取副作用函数，这种硬编码的方式很不灵活。副作用
 * 函数的名字可以任意取，我们完全可以把副作用函数命名为
 * myEffect，甚至是一个匿名函数，因此我们要想办法去掉这种硬编码
 * 的机制。下一节会详细讲解这一点，这里大家只需要理解响应式数据
 * 的基本实现和工作原理即可。
 */

